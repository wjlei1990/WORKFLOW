module measure_adj_subs

!>measure_adj_asdf

!!measure_adj based on asdf data format

contains

!> measure_adj_sub
!! input:
!! @param data  observed seismogram
!! @param npt1  npoints of obsd data
!! @param t01   begin time of obsd data
!! @param dt1   time_step of obsd data
!! @param syn   synthetic seismogram
!! @param npt2  npoints
!! @param t02   begin time
!! @param dt2   time step
!! @param dist  distance from station to event
!! @param sta   station name
!! @param net   network name
!! @param chan_dat   observed channel name(LHZ, LHR, LHT)
!! @param win_all   win info of one pair of data generated by flexwin
!! @param measure_adj_par   measure_adj parameter struct
!! @param weighting_par     weighting variables
!! output:
!! @param win_chi_all   win_chi_all struct, contains all the win_chi info
!! @param adj_syn_all   adj_seismogram

subroutine measure_adj(data_in,npt1_in,t01_in,dt1_in, &
              syn_in,npt2_in,t02_in,dt2_in, &
              dist_in, sta, net, chan_dat, &
              win_all, ma_par_all, weighting_par, &
              win_chi_all, adj_source)

  !  main program that calls the subroutines to make measurements within input time windows
  !  and then compute the corresponding adjoint sources

  ! input parameter:
  !  1. imeas = 1, normalized waveform difference. Adjoint source is constructed from the data
  !                      only, with the form -d(t)/ || d(t) || 2
  !  2. imeas = 2, waveform difference, s(t) âˆ’ d(t).
  !  3. imeas = 3, cross-correlation traveltime difference for a (banana-doughtnut) sensitivity ker-
  !                       nel. The measurement between data and synthetics is not used in constructing the adjoint
  !                       source.
  !  4. imeas = 4, amplitude difference for a (banana-doughtnut) sensitivity kernel. The measure-
  !                       ment between data and synthetics is not used in constructing the adjoint source.
  !  5. imeas = 5, cross-correlation traveltime difference for an event kernel. The measurement
  !                       between data and synthetics is used in constructing the adjoint source.
  !  6. imeas = 6, amplitude difference for an event kernel. The measurement between data and
  !                        synthetics is used in constructing the adjoint source.
  !  7. imeas = 7, multitaper traveltime difference for an event kernel. The measurement between
  !                       data and synthetics is used in constructing the adjoint source. See multitaper_notes.pdf.
  !  8. imeas = 8, multitaper amplitude difference for an event kernel. The measurement between
  !                       data and synthetics is used in constructing the adjoint source. See multitaper_notes.pdf.

  use ma_variables
  use ma_constants
  !use ascii_rw       ! dwascii()
  use ma_sub2        ! fft(), fftinv()
  use ma_sub         ! mt_measure(), mt_adj()
  use ma_weighting 

  !use asdf_data
  use flexwin_struct
  use ma_struct

  implicit none
  
  !mpi variables
  !type(asdf_event),intent(in) :: obsd_all, synt_all
  !type(asdf_event),intent(inout) :: adj_all

  real, intent(in) :: data_in(*), syn_in(*)
  real :: t01_in, dt1_in, t02_in, dt2_in
  real :: dist_in
  integer :: npt1_in, npt2_in
  character(len=*) :: sta, net, chan_dat

  type(ma_par_struct_all) :: ma_par_all
  type(ma_weighting_par_struct) :: weighting_par
  type(win_info),intent(in) :: win_all
  type(win_chi_info),intent(inout) :: win_chi_all

  real :: adj_source(:)


  character(len=150) :: datafile,synfile,synfile_phydisp,file_prefix,file_prefix0,file_prefix2,measure_file_prefix,adj_file_prefix
  integer :: num_meas, j, ios, npt1, npt2,npt3, npts, nn 
  double precision, dimension(NDIM) :: data, syn, syn_phydisp, adj_syn_all, &
                        tr_adj_src, am_adj_src, recon_cc_all, syn_dtw_cc, syn_dtw_mt
  double precision :: t01, dt1, t02, dt2, t03, dt3, t0, dt, tstart, tend, tt, dtt, df
  double precision, dimension(NCHI) :: window_chi
  double precision :: fend0, fstart0, fend, fstart

  ! sac header information
  integer :: yr,jda,ho,mi
  double precision :: sec,dist,az,baz,slat,slon
  character(len=10) :: chan,cmp,chan_syn
  double precision :: tshift, sigma_dt_cc, dlnA, sigma_dlnA_cc, sigma_dt, sigma_dlnA
  double precision :: all_chi, tr_chi, am_chi, cc_max, T_pmax_dat, T_pmax_syn
  !double precision :: tshift_f1f2, cc_max_f1f2
  double precision, dimension(NPT) :: dtau_w, dlnA_w, err_dt, err_dlnA, syn_dtw, data_dtw,syn_dtw_phydisp
  complex*16, dimension(NPT) :: trans_mtm
  integer :: nlen, i_left, i_pmax_dat, i_pmax_syn, i_right, i_right0, istart, &
        ipair, npairs, nwin, itmax 
  logical :: use_trace 
  !double precision :: trbdndw, a
  !integer :: iord, passes
  integer :: ipick_type
  double precision :: T_surfacewaves

  integer :: nerr
  !>init adj_all

  !********* PROGRAM STARTS HERE *********************
  ! read in MEASUREMENT.PAR (see ma_sub.f90 and write_par_file.pl)
  ! most parameters are global (see ma_variables.f90)
  !call read_par_file(fstart0,fend0,tt,dtt,nn,chan)

  ! uses weights to balance love and rayleigh measurements
  ! we do a normalization of P_SV, P_SH, Love, Rayleigh with the number of measurement picks
  !if( DO_WEIGHTING ) call setup_weighting(chan)

  ! input file: MEASUREMENT.WINDOWS
  !open(11,file='MEASUREMENT.WINDOWS',status='old',iostat=ios)
  !if (ios /= 0) stop 'Error opening input file: MEASUREMENT WINDOWS' 

  !read(11,*,iostat=ios) npairs
  !if (ios /= 0) stop 'Error reading number of pairs of data/syn'
  !print *, 'reading in the data and synthetics...'

  ! output files
  !open(12,file='window_index',status='unknown',iostat=ios)
  !open(13,file='window_chi',status='unknown',iostat=ios)

  !nwin = 0; all_chi=0.

  !do ipair = 1, obsd_all%nrecords

  !copy from argument list to local var(because the data type is different)
    data(:) = 0.0
    syn(:)  = 0.0

    adj_syn_all(:) = 0.0
    recon_cc_all(:) = 0.0

    !print *,"Just start"
    call copy_argu_to_local_and_check(data_in,npt1_in,t01_in,dt1_in, &
          syn_in,npt2_in,t02_in,dt2_in,dist_in, &
          data,npt1,t01,dt1,syn,npt2,t02,dt2,dist,&
          npts,dt,t0,nerr)
    
    !print *,"1"
    call copy_ma_par_to_local(ma_par_all%Z, fstart0, fend0,tt,dtt,nn,chan)

    !print *,"2"
    call copy_weighting_par_to_local(weighting_par)

    !DEBUG
    print *,"In measure_adj: copy finished"

    ! reads in file names for data and synthetics
    !read(11,'(a)',iostat=ios) datafile
    !if (ios /= 0) stop 'Error reading windows file'
    !read(11,'(a)',iostat=ios) synfile
    !if (ios /= 0) stop 'Error reading windows file'
    !if (USE_PHYSICAL_DISPERSION) then
    !       synfile_phydisp=trim(synfile)//'.phydisp'
    !end if 


    ! read data and syn (in double precision)
    ! LQY: data is read last to be stored in memory for header retrieval later

    !>transfer data
    !call drsac1(datafile,data,npt1,t01,dt1)
    !npt1 = obsd_all%npoints(ipair)
    !t01 = obsd_all%begin_value(ipair)
    !dt1 = obsd_all%sample_rate(ipair)
    !data(1:npt1) = dble(obsd_all%records(ipair)%record(1:npt1))
    !call drsac1(synfile,syn,npt2,t02,dt2)
    !npt2 = synt_all%npoints(ipair)
    !t02 = synt_all%begin_value(ipair)
    !dt2 = synt_all%sample_rate(ipair) 
    !syn(1:npt2) = dble(synt_all%records(ipair)%record(1:npt2))

    !if (USE_PHYSICAL_DISPERSION) then 
    !        call drsac1(synfile_phydisp,syn_phydisp,npt3,t03,dt3)
    !end if 

    !print*, "here?"

    if (DISPLAY_DETAILS) then
       print *
       print *, 'data: '   !,trim(datafile)
       print *, '  min/max: ',sngl(minval(data(:))),sngl(maxval(data(:)))
       
       print *, 'syn:   '  !,trim(synfile)
       print *, '  min/max: ',sngl(minval(syn(:))),sngl(maxval(syn(:)))
    endif

    ! check if npts, dt, t0 matches for data and synthetics
    ! no interpolation is necessary at any point
    !if (max(npt1,npt2) > NDIM) &
    !     stop 'Error: Too many number of points in data or syn'
    !npts = min(npt1,npt2)

    !if (abs(dt1-dt2) > TOL) stop 'Error: check if dt match' 
    !dt = dt1

    !if (abs(t01-t02) > dt)  stop 'Check if t0 match'
    !t0 = t01

    if (DISPLAY_DETAILS) print *,'  time, dt, npts :',sngl(t01), sngl(dt), npts
    

    ! apply bandpass filter to data and synthetics with saclib, if desired
    ! http://www.iris.washington.edu/pipermail/sac-help/2008-March/000376.html
    ! Access to the kidate, xapiir, and getfil is not simple and not
    ! supported under the current state of the SAC code base.

    if(RUN_BANDPASS) then
       call bandpass(data,npts,dt,fstart0,fend0)
       call bandpass(syn,npts,dt,fstart0,fend0)
       if (USE_PHYSICAL_DISPERSION) then 
               call bandpass(syn_phydisp,npts,dt,fstart0,fend0)
       end if 
    endif

    ! find out station/network/comp names,etc from synthetics
    !call get_sacfile_header(trim(synfile),yr,jda,ho,mi,sec,net,sta, &
    !                      chan_dat,dist,az,baz,slat,slon)

    ! theoretical surface wave arrival time
    !dist = obsd_all%great_circle_dist(ipair)
    T_surfacewaves = dist / surface_vel

    ! synthetics always have the form BH_ or LH_, but the data may not (HH_, LH_, BL_, etc).
    !chan needs to be modified
    !sta, net, cha_syn need to be modified
    !sta = ""
    !net = synt_all%network((3*ipair-2):(3*ipair-1))
    !chan_dat = obsd_all%component((4*ipair-3):(4*ipair-1))
    cmp = chan_dat(3:3)
    chan_syn = trim(chan)//trim(cmp)
    !print *,"here???"

    !print *, trim(sta),trim(net),trim(chan_syn)
    ! example: OUT/PAS.CI.BHZ
    file_prefix0 = trim(sta)//'.'//trim(net)//'.'//trim(chan_syn)
    !print *, file_prefix0
    file_prefix2 = trim(OUT_DIR)//'/'//trim(file_prefix0)
    !print *,trim(OUT_DIR)
    !print *
    !print *,  trim(file_prefix2), ' --- '
    print *, ' --- '

    !print *,"here?????"
    !print *, imeas0
    !print *, trim(file_prefix2)
    ! note: MT measurement could revert to CC, but still keep the MT suffix
    write(adj_file_prefix,'(a,i2.2)') trim(file_prefix2)//'.iker', imeas0

    !print *,"here????"
    ! reads number of measurement windows
    !read(11,*,iostat=ios) num_meas
    !if (ios /= 0) stop 'Error reading num_meas'
    num_meas=win_all%num_win

    win_chi_all%num_win=win_all%num_win
    win_chi_all%num_measurement=NCHI

    !!allocate win_chi_all here
    allocate(win_chi_all%chi(num_meas,NCHI))
    allocate(win_chi_all%imeas(num_meas))
    allocate(win_chi_all%tr_chi(num_meas))
    allocate(win_chi_all%am_chi(num_meas))
    allocate(win_chi_all%T_pmax_dat(num_meas))
    allocate(win_chi_all%T_pmax_syn(num_meas))

    !print *,"here??"

    do j = 1, num_meas
      ! reads in start and end time of the measurement window
      !read(11,*,iostat=ios) tstart, tend
      !if (ios /= 0) stop 'Error reading tstart and tend' 
      tstart = win_all%t_start(j)
      tend = win_all%t_end(j)

      ! checks start and end times of window compared to trace lengths
      tstart = max(tstart,t0)
      tend = min(tend, t0+(npts-1)*dt)
      nlen = floor((tend-tstart)/dt) + 1  ! dummy, replaced later in mt_measure()

      ! write values to output file
      !nwin = nwin + 1       ! overall window counter
      !write(12,'(a3,a8,a5,a5,3i5,2f12.3)') net,sta,chan_syn,chan_dat,nwin,ipair,j,tstart,tend

      !print *,"here111"
      ! add taper type to file prefix: OUT/PAS.CI.BHZ.01.mtm
      write(file_prefix,'(a,i2.2)') trim(file_prefix2)//'.', j

      if (is_mtm == 1) then
        measure_file_prefix = trim(file_prefix) // '.mtm'  ! multitaper taper
      elseif (is_mtm == 2) then
        measure_file_prefix = trim(file_prefix) // '.ctp'  ! cosine taper
      else
        measure_file_prefix = trim(file_prefix) // '.btp'  ! boxcar taper
      endif

      print *
      print *, ' Measurement window No.', j, ' ... '

      ! initialize the measurements
      window_chi(:) = 0.

      ! compute integrated waveform difference, normalized by duration of the record
      ! NOTE: (1) this is for the FULL record, not the windowed record
      !       (2) for comparison with waveform_chi, we include the 0.5 factor
      !       (3) we might want to include dt as an integration factor (also for waveform_chi),
      !           but the ratio (d-s)^2 / d^2 avoids the need for dt, nstep, or length of record
      window_chi(17) = 0.5 * sum( data**2 )
      window_chi(18) = 0.5 * sum( syn**2 )
      window_chi(19) = 0.5 * sum( (data-syn)**2 )
      window_chi(20) = npts*dt

      ! make measurements
      ! also compute reconstructed synthetics for CC (and MT, if specified) measurements
      call mt_measure(datafile,measure_file_prefix,data,syn,syn_phydisp,t0,dt,npts,tstart,tend,&
            istart,data_dtw,syn_dtw,syn_dtw_phydisp,nlen,tshift,sigma_dt_cc,dlnA,sigma_dlnA_cc,cc_max,syn_dtw_cc,&
            i_pmax_dat,i_pmax_syn,i_right0,trans_mtm,dtau_w,dlnA_w,sigma_dt,sigma_dlnA,syn_dtw_mt,err_dt,err_dlnA)
      i_right = i_right0
      i_left = 1  ! LQY: is it feasible that i_left is not 1? mt_adj() inherently assumes it.

      !print*, "here?"

      ! period of the max power of the synthetic record
      T_pmax_dat = (dt*NPT) / dble(i_pmax_dat)
      T_pmax_syn = (dt*NPT) / dble(i_pmax_syn)

      ! adjust frequency ranges for MT measurements
      ! fstart is constrained by NCYCLE_IN_WINDOW/tlen, fend constrained by i_right
      if (is_mtm == 1) then
         fstart = fstart0  ; fend = fend0
         call mt_measure_select(nlen,tshift,i_pmax_syn,dtau_w,err_dt, &
                              dt,i_left,i_right,fstart,fend,use_trace)
         print *, '     Tlong/Tshort (input) :', sngl(1/fstart0), sngl(1/fend0)
         print *, '     Tlong/Tshort (adjusted)  :', sngl(1/fstart), sngl(1/fend)
         print *, '     period of max data/syn power    :', sngl(T_pmax_dat), sngl(T_pmax_syn)

         ! if MT measurement window is rejected by mt_measure_select, then use a CC measurement
         if(.not. use_trace) then
            !stop 'Check why this MT measurement was rejected'
            print *, '   reverting from MT measurement to CC measurement...'
            imeas = imeas0 - 2
            is_mtm = 2  ! LQY: WHY not is_mtm = 2?
            call mt_measure(datafile,measure_file_prefix,data,syn,syn_phydisp,t0,dt,npts,tstart,tend,&
                  istart,data_dtw,syn_dtw,syn_dtw_phydisp,nlen,&
                  tshift,sigma_dt_cc,dlnA,sigma_dlnA_cc,cc_max,syn_dtw_cc,&
                  i_pmax_dat,i_pmax_syn,i_right,trans_mtm,dtau_w,dlnA_w,sigma_dt,sigma_dlnA,syn_dtw_mt)
         else
            print *, '     using this MTM. '
         endif
      endif

      ! check that the CC measurements are within the specified input range
      if (imeas >= 5) call cc_measure_select(tshift,dlnA,cc_max)

      ! write frequency limits to file
      if (OUTPUT_MEASUREMENT_FILES) then
        df = 1./(dt*NPT)
        open(71,file=trim(measure_file_prefix)//'.freq_limits')
        write(71,'(6f18.8)') fstart0, fend0, df, i_right0*df, fstart, fend
        close(71)
      endif

      ! compute adjoint sources and misfit function values and also the CC-reconstructed records
      if (COMPUTE_ADJOINT_SOURCE) then
         print *, '   Generating adjoint source and chi value for imeas = ', imeas

        ! banana-doughnut kernel (needs only synthetic trace) 
        ! LQY: what is this section intended to do?
        ! reset imeas == 3 for adjoint sources without time shift and uncertainty scaling
        ! (pure cross-correlation adjoint source for banana-doughnuts)
        if(imeas == 5 .and. trim(datafile) == trim(synfile) ) then
           print*,'cross-correlation measurement:'
           print*,'  only synthetic file: ',trim(synfile)
           print*,'    without traveltime difference/uncertainty'
           print*
           imeas = 3
        endif

        tr_chi = 0.0 ; am_chi = 0.0    ! must be initialized
        call mt_adj(istart,data_dtw,syn_dtw,syn_dtw_phydisp,nlen,dt,tshift,dlnA,sigma_dt_cc,sigma_dlnA_cc,&
             dtau_w,dlnA_w,err_dt,err_dlnA,sigma_dt,sigma_dlnA,i_left,i_right,&
             window_chi,tr_adj_src,tr_chi,am_adj_src,am_chi)

        ! KEY: write misfit function values to file (two for each window)
        ! Here are the 20 columns of the vector window_chi
        !  1: MT-TT chi,    2: MT-dlnA chi,    3: XC-TT chi,    4: XC-dlnA chi
        !  5: MT-TT meas,   6: MT-dlnA meas,   7: XC-TT meas,   8: XC-dlnA meas
        !  9: MT-TT error, 10: MT-dlnA error, 11: XC-TT error, 12: XC-dlnA error
        ! WINDOW     : 13: data power, 14: syn power, 15: (data-syn) power, 16: window duration
        ! FULL RECORD: 17: data power, 18: syn power, 19: (data-syn) power, 20: record duration
        ! Example of a reduced file: awk '{print $2,$3,$4,$5,$6,$31,$32}' window_chi > window_chi_sub
        !write(13,'(a14,a8,a3,a5,i4,i4,2e14.6,20e14.6,2e14.6,2f14.6)') &
        !   file_prefix0,sta,net,chan_syn,j,imeas,&
        !   tstart,tend,window_chi(:),tr_chi,am_chi,T_pmax_dat,T_pmax_syn
        !print *, '     tr_chi = ', sngl(tr_chi), '  am_chi = ', sngl(am_chi)

        !>put data into struct
        win_chi_all%chi(j,:)=window_chi(:)
        win_chi_all%imeas(j)=imeas
        win_chi_all%tr_chi(j)=tr_chi
        win_chi_all%am_chi(j)=am_chi
        win_chi_all%T_pmax_dat(j)=T_pmax_dat
        win_chi_all%T_pmax_syn(j)=T_pmax_syn

        ! uses weighting to balance love / rayleigh measurements
        if( DO_WEIGHTING ) then
           ipick_type = 0
           if( tend <= T_surfacewaves ) then
              ! body wave picks
              if( cmp(1:1) == "Z" ) ipick_type = P_SV_V
              if( cmp(1:1) == "R" ) ipick_type = P_SV_R
              if( cmp(1:1) == "T" ) ipick_type = SH_T
           else
              ! surface wave picks
              if( cmp(1:1) == "Z" ) ipick_type = Rayleigh_V
              if( cmp(1:1) == "R" ) ipick_type = Rayleigh_R
              if( cmp(1:1) == "T" ) ipick_type = Love_T
           endif

          ! LQY: shouldn't chi values be changed accordingly?????
          ! No total chi value is calculated ...

          ! weights by phase types
          select case(ipick_type)
            case( P_SV_V )
              tr_adj_src(:) = tr_adj_src(:) * num_P_SV_V
              tr_chi = tr_chi * num_P_SV_V
            case( P_SV_R )
              tr_adj_src(:) = tr_adj_src(:) * num_P_SV_R
              tr_chi = tr_chi * num_P_SV_R
            case( SH_T )
              tr_adj_src(:) = tr_adj_src(:) * num_SH_T
              tr_chi = tr_chi * num_SH_T
            case( Rayleigh_V )
              tr_adj_src(:) = tr_adj_src(:) * num_Rayleigh_V
              tr_chi = tr_chi * num_Rayleigh_V
            case( Rayleigh_R )
              tr_adj_src(:) = tr_adj_src(:) * num_Rayleigh_R
              tr_chi = tr_chi * num_Rayleigh_R
            case( Love_T )
              tr_adj_src(:) = tr_adj_src(:) * num_Love_T
              tr_chi = tr_chi * num_Love_T
            case default
              stop 'error ipick_type unknown'
          end select
       endif

        ! combine adjoint sources from different measurement windows

        !Q: Why the am_adj_src doesn't need to be weighted???(WL)
       if (mod(imeas,2)==1) then
          adj_syn_all(:) = adj_syn_all(:) + tr_adj_src(:)   ! imeas = 1,3,5,7
          !all_chi = all_chi + tr_chi
       else
          adj_syn_all(:) = adj_syn_all(:) + am_adj_src(:)   ! imeas = 2,4,6,8
          !all_chi = all_chi + am_chi
       endif
      
        ! combine CC-reconstructed records
       if (imeas >= 7) then
          recon_cc_all(istart:istart+nlen-1) = recon_cc_all(istart:istart+nlen-1) + syn_dtw_mt(1:nlen)
       else
          recon_cc_all(istart:istart+nlen-1) = recon_cc_all(istart:istart+nlen-1) + syn_dtw_cc(1:nlen)
       endif

     endif ! COMPUTE_ADJOINT_SOURCE

      ! CHT: (re-)set to multitaper parameters, if originally specified
      if (is_mtm0 == 1) then
         imeas = imeas0
         is_mtm = is_mtm0
      endif

   enddo ! nmeas

    !----------------------------
    ! write out the adjoint source for the trace (STA.NI.CMP) by combining contribution from all wins

    if (COMPUTE_ADJOINT_SOURCE) then

    ! write out the CC-reconstructed data from synthetics
       if (OUTPUT_MEASUREMENT_FILES) &
            call dwsac1(trim(file_prefix2)//'.recon.sac',recon_cc_all,npts,t0,dt)

      !!TODO: add doc
      ! OPTIONAL: A conservative choice is to filter the adjoint source,
      !   since higher frequencies could enter from the tapering operations.
      ! Note: time_window in mt_adj.f90 tapers the windows.

      ! note also:
      ! measurements are done on filtered synthetics F(s) and filtered data F(d), such that DeltaT
      ! is given for filtered data & synthetics.
      ! then kernels,
      ! i.e. for a traveltime measurement: DeltaT = 1/N * int  F(d/dt s) F(ds)
      ! should contain this filter as well.
      ! 
      ! when we construct the adjoint source here,it is initially a filtered version
      ! as well F(s_adj) since we use/depend on filtered synthetics F(s).
      ! however, for kernel simulations, we do run with a reconstructed forward wavefield,
      ! which is unfiltered (only filter there is by source half-time), but we want to convolve
      !  K = int F*(s_adj) F(s)
      ! using the same (bandpass) filter F() as used for filtereing data & synthetics in the meausurements
      ! We can write the kernel expression as K = int F*{F* (s_adj)}  s
      ! thus we should apply the filter F() twice on the adjoint source
      !
      ! why is this important? the filter, like bandpassing, is usually acausal, that is, it can
      ! introduce a slight phase-shift to the data. but, phase-shifts is what we are interested in
      ! and invert for. so, filtering might affect our inversions...

      ! we do use a bandpass filter here again on the adjoint source. this is slightly different
      ! to the transfer function filter in SAC used initially to filter data & synthetics.
      ! but this seems to be the best and fairly easy what we can do here...
      call bandpass(adj_syn_all,npts,dt,fstart0,fend0) ! sac butterworth filter

      ! cut and interpolate to match time-stepping for SEM
      ! NOTE: This can leave a non-zero value to start the record,
      !       which is NOT GOOD for the SEM simulation.
      call interpolate_syn(adj_syn_all,t0,dt,npts,tt,dtt,nn)

      ! Taper the start of the adjoint source, since cutting the record
      ! may have left a non-zero value to start the record,
      ! which is not good for the SEM simulation.
      itmax = int(TSHORT/dtt)
      call taper_start(adj_syn_all,nn,itmax)

      ! output the adjoint source (or ray density) as ASCII or SAC format
      print *, 'writing adjoint source to file for the full seismogram'
      !if( DO_RAY_DENSITY_SOURCE ) then
        !call dwascii(trim(adj_file_prefix)//'.density.adj',adj_syn_all,nn,tt,dtt)
      !else
        !call dwascii(trim(adj_file_prefix)//'.adj',adj_syn_all,nn,tt,dtt)
        
        
        ! LQY add the sum of chi values (total misfit), weights included if DO_WEIGHTING on
        !put adj_syn_all


        !>Wenjie: put "all_chi" in win_chi_all%all_chi
        !open(14,file='window_chi_sum',status='unknown')
        !write(14,*) all_chi
        !close(14)
      !endif

      !allocate record
      !put adj_syn_all in the struct
      !allocate(adj_all%records(ipair)%record(nn))
      !adj_all%npoints(ipair)=nn
      !adj_all%sample_rate(ipair)=dtt
      !adj_all%begin_value(ipair)=tt

      !adj_source(1:nn)=sngl(adj_syn_all(1:nn))

    endif

  !enddo ! npairs


  !close(11)  ! read: MEASUREMENT.WINDOWS
  !close(12)  ! write: window_index
  !close(13)  ! write: window_chi

end subroutine measure_adj

!subroutine copy_measure_adj_par

!end subroutine copy_measure_adj_par
subroutine copy_argu_to_local_and_check(data_in,npt1_in,t01_in,dt1_in, &
              syn_in,npt2_in,t02_in,dt2_in,dist_in, &
              data,npt1,t01,dt1,syn,npt2,t02,dt2,dist, &
              npts,dt,t0,nerr) 
  
  use ma_sub2, only : TOL
  use ma_constants, only : NDIM
  
  real, intent(in) :: data_in(*), syn_in(*)
  real :: t01_in, dt1_in, t02_in, dt2_in
  real :: dist_in
  integer :: npt1_in, npt2_in

  double precision, dimension(NDIM) :: data, syn
  double precision :: t01, t02, dt1, dt2
  double precision :: dist
  integer :: npt1, npt2

  integer :: npts
  double precision :: dt,t0
  integer :: nerr

  !copy
  t01=dble(t01_in)
  t02=dble(t02_in)
  dt1=dble(dt1_in)
  dt2=dble(dt2_in)
  npt1=npt1_in
  npt2=npt2_in

  !check
  if(max(npt1,npt2) > NDIM) &
      stop 'ERROR: Too many number of points in data or syn'
  npts = min(npt1, npt2)

  if(abs(dt1-dt2) > TOL) stop 'ERROR: check if dt match(data and syn)'
  dt=dt1

  if(abs(t01-t02) > dt) stop 'Check if t0 match(data and syn)'
  t0=t01

  data(1:npt1)=dble(data_in(1:npt1))
  syn(1:npt2)=dble(syn_in(1:npt2))

  dist=dble(dist_in)

  nerr=0

end subroutine copy_argu_to_local_and_check

!-----------------------------------------------------.
!read measure_adj par all, called by main program     !
!-----------------------------------------------------'
subroutine read_ma_parfile(measure_adj_par_all, fstart, fend)

  use ma_struct

  type(ma_par_struct_all) :: measure_adj_par_all
  real,intent(in) :: fstart, fend
  integer :: fstart_temp, fend_temp
  character(len=5) :: fstart_string, fend_string
  character(len=150) :: fn
  
  !frequency info
  fstart_temp=int(fstart)
  fend_temp=int(fend)

  !print *,"here"
  !print *,"fstart, fend:", fstart, fend
  !write(fstart_string,'(I3)') fstart_temp
  !write(fend_string, '(I3)') fend_temp
  !print *,"fstart_string, fend_string:", fstart_temp, fend_temp

  fn="./MEASUREMENT.PAR"
  call read_ma_parfile_comp(fn, measure_adj_par_all%Z) 
  fn="./MEASUREMENT.PAR"
  call read_ma_parfile_comp(fn, measure_adj_par_all%R) 
  fn="./MEASUREMENT.PAR"
  call read_ma_parfile_comp(fn, measure_adj_par_all%T) 

end subroutine read_ma_parfile

subroutine read_ma_parfile_comp(fn, ma_par)

use ma_constants, only : NDIM, DO_RAY_DENSITY_SOURCE
    use ma_struct

    implicit none

    character(len=*),intent(in) :: fn
    type(ma_par_struct) :: ma_par

    !subroutine read_par_file(fstart0,fend0,tt,dtt,nn,chan)

    !double precision, intent(out) :: fstart0,fend0,tt,dtt
    !integer, intent(out) :: nn
    !character(len=10), intent(out) :: chan
    integer :: ios

    integer :: imeas, is_mtm
    double precision :: fstart0, fend0

    ! input file MEASUREMENT.PAR -- see write_par_file.pl for details

    !OUT_DIR = 'OUTPUT_FILES'   ! default

    open(10,file=fn,status='old',iostat=ios)
    if ( ios /= 0) stop 'Error opening MEASUREMENT.PAR file'
     read(10,*) ma_par%tt, ma_par%dtt, ma_par%nn
     read(10,*) ma_par%imeas0
     read(10,*) ma_par%chan
     read(10,*) ma_par%TLONG, ma_par%TSHORT
     read(10,*) ma_par%RUN_BANDPASS
     read(10,*) ma_par%DISPLAY_DETAILS
     read(10,*) ma_par%OUTPUT_MEASUREMENT_FILES
     read(10,*) ma_par%COMPUTE_ADJOINT_SOURCE
     read(10,*) ma_par%TSHIFT_MIN, ma_par%TSHIFT_MAX
     read(10,*) ma_par%DLNA_MIN, ma_par%DLNA_MAX
     read(10,*) ma_par%CC_MIN
     read(10,*) ma_par%ERROR_TYPE
     read(10,*) ma_par%DT_SIGMA_MIN
     read(10,*) ma_par%DLNA_SIGMA_MIN
     read(10,*) ma_par%ITAPER
     read(10,*) ma_par%WTR,ma_par%NPI
     read(10,*) ma_par%DT_FAC
     read(10,*) ma_par%ERR_FAC
     read(10,*) ma_par%DT_MAX_SCALE
     read(10,*) ma_par%NCYCLE_IN_WINDOW
     read(10,*) ma_par%USE_PHYSICAL_DISPERSION
     close(10)

     !>remember modify here!!!!!
     imeas = ma_par%imeas0

     ! check the read-in values
     print *, 'INPUTS FROM MEASUREMENT.PAR :'
     print *, '  tt, dtt, nn : ',sngl(ma_par%tt),sngl(ma_par%dtt),ma_par%nn
     print *, '  imeas : ',ma_par%imeas0
     print *, '  chan : ',ma_par%chan
     print *, '  TLONG, TSHORT : ',sngl(ma_par%TLONG), sngl(ma_par%TSHORT)
     ma_par%fstart0 = 1./ma_par%TLONG ; ma_par%fend0 = 1./ma_par%TSHORT
     print *, '  fstart, fend : ', sngl(ma_par%fstart0), sngl(ma_par%fend0)
     print *, '  RUN_BANDPASS : ',ma_par%RUN_BANDPASS
     print *, '  DISPLAY_DETAILS : ',ma_par%DISPLAY_DETAILS
     print *, '  OUTPUT_MEASUREMENT_FILES : ',ma_par%OUTPUT_MEASUREMENT_FILES
     print *, '  COMPUTE_ADJOINT_SOURCE : ',ma_par%COMPUTE_ADJOINT_SOURCE
     print *, '  TSHIFT_MIN, TSHIFT_MAX : ',sngl(ma_par%TSHIFT_MIN), sngl(ma_par%TSHIFT_MAX)
     print *, '  DLNA_MIN, DLNA_MAX : ',sngl(ma_par%DLNA_MIN), sngl(ma_par%DLNA_MAX)
     print *, '  CC_MIN : ',sngl(ma_par%CC_MIN)
     print *, '  ERROR_TYPE : ',ma_par%ERROR_TYPE
     print *, '  DT_SIGMA_MIN : ',sngl(ma_par%DT_SIGMA_MIN)
     print *, '  DLNA_SIGMA_MIN : ',sngl(ma_par%DLNA_SIGMA_MIN)
     print *, '  ITAPER : ',ma_par%ITAPER
     print *, '  WTR, NPI : ',sngl(ma_par%WTR),ma_par%NPI
     print *, '  DT_FAC : ',sngl(ma_par%DT_FAC)
     print *, '  ERR_FAC : ',sngl(ma_par%ERR_FAC)
     print *, '  DT_MAX_SCALE : ',sngl(ma_par%DT_MAX_SCALE)
     print *, '  NCYCLE_IN_WINDOW : ',ma_par%NCYCLE_IN_WINDOW
     !stop 'checking PAR file input'

     ! ray density
    if( DO_RAY_DENSITY_SOURCE ) ma_par%ERROR_TYPE = 0

     ! assign additional parameters and stop for certain inconsistencies
    if (ma_par%fstart0 >= ma_par%fend0) &
          stop 'Check input frequency range of the signal'
        
    if (ma_par%nn > NDIM) &
        stop 'Error: Change interpolation nn or NDIM'

    ! LQY: what happens if imeas = 7/8, and itaper = 2,3, is that permitted?
    ! LQY: how about imeas = 1/2, itaper = 1,2,3 matters?

    if ( imeas == 1 .or. imeas == 2 ) then ! waveforms
      ma_par%is_mtm0 = 0
    elseif ( imeas >= 3 .and. imeas <= 6 ) then ! CC Dt/DlnA
      ! for CC kernels, ITAPER must be a single taper (2 or 3)
      if ( ma_par%ITAPER == 1 ) stop 'Error: Change ITAPER to 2/3 for CC measurements'
      ma_par%is_mtm0 = ma_par%ITAPER     ! 2 or 3 for CC adjoint sources
    elseif ( imeas==7 .or. imeas==8 ) then 
      ma_par%is_mtm0 = 1          ! multitaper required for MT adjoint source
    else
      stop 'Error: imeas must by 1-8'
    endif

    is_mtm = ma_par%is_mtm0
    print *, '  is_mtm :',is_mtm
    print *, ' '

end subroutine read_ma_parfile_comp

!-------------------------------------------------.
!set up weigthing par, called by main program     !
!-------------------------------------------------'
subroutine setup_measure_adj_weighting_asdf(win,npairs,dist,chan_array,ma_par)
  
  !window count
  use flexwin_struct
  use ma_struct
  use ma_weighting

  use ma_constants, only : NDIM
  use ma_sub2, only : TOL
  !use ma_weighting, only : surface_vel

  implicit none

  type(win_info),intent(in) :: win(:)
  integer :: npairs
  character(len=*), intent(in) :: chan_array(:)
  real,intent(in) :: dist(:)

  type(ma_weighting_par_struct) :: ma_par

  !
  ! determines weights based on number of window picks on Z/R/T components
  !

  !character(len=10),intent(in) :: chan_syn

  ! local parameters
  !integer :: npairs,ios,ipair,iposition,ipicks
  integer :: ios,ipair,iposition,ipicks
  !character(len=150) :: datafile,synfile !,dummy
  character(len=4) :: comp_T,comp_Z,comp_R
  integer :: picks_T, picks_Z, picks_R,npicks
  ! sac header information
  !integer :: yr,jda,ho,mi
  !double precision :: sec,dist,az,baz,slat,slon,T_surfacewaves
  double precision :: T_surfacewaves
  character(len=10) :: net,sta,chan_dat,chan,cmp
  double precision :: t01, dt1, t02, dt2, t0, dt, tstart, tend
  integer :: npt1, npt2, npts
  !double precision, dimension(NDIM) :: data, syn

  !call get_sacfile_header(trim(datafile),yr,jda,ho,mi,sec,net,sta, &
  !                        chan_dat,dist,az,baz,slat,slon)
  ! initializes

  print *,"dist:"
  print *, dist(:)

  !print *, chan_array(:)(:)

  picks_R = 0
  picks_Z = 0
  picks_T = 0

  num_P_SV_V = 0.d0
  num_P_SV_R = 0.d0
  num_SH_T = 0.d0

  num_Rayleigh_V = 0.d0
  num_Rayleigh_R = 0.d0
  num_Love_T = 0.d0

  ! substrings (synthetics components)
  !comp_T = trim(chan_syn)//"T."
  !comp_R = trim(chan_syn)//"R."
  !comp_Z = trim(chan_syn)//"Z."

  ! opens measurement windows
  !open(21,file='MEASUREMENT.WINDOWS',status='old',iostat=ios)
  !if (ios /= 0) stop 'Error opening input file: MEASUREMENT WINDOWS'
  !read(21,*,iostat=ios) npairs
  !if (ios /= 0) stop 'Error reading number of pairs of data/syn'
  ! loops through windows
  do ipair=1, npairs

    ! reads in file names
    !read(21,'(a)',iostat=ios) datafile
    !if (ios /= 0) stop 'Error reading windows datafile'
    !read(21,'(a)',iostat=ios) synfile
    !if (ios /= 0) stop 'Error reading windows synfile'

    ! read data and syn (read datafile last to take its header later)
    !call drsac1(synfile,syn,npt2,t02,dt2)
    !call drsac1(datafile,data,npt1,t01,dt1)

    !if (max(npt1,npt2) > NDIM) &
    !    stop 'Error: Too many npts in data or syn'
    
    ! check if t0 and dt match
    !if (abs(dt1-dt2) > TOL) stop 'Error: check if dt match'
    !dt = dt1
    !npts = min(npt1,npt2)
    !if (abs(t01-t02) > dt) then
    !  print *,'data t0: ',t01
    !  print *,'syn  t0: ',t02
    !  stop 'Check if t0 match'
    !endif
    !t0 = t01

    ! figure out station/network/comp names, etc
    !call get_sacfile_header(trim(datafile),yr,jda,ho,mi,sec,net,sta, &
    !                        chan_dat,dist,az,baz,slat,slon)
    chan = chan_array(ipair)
    cmp = chan_array(ipair)(3:3)

    ! theoretical surface wave arrival time
    T_surfacewaves = dist(ipair)/180.0*3.1415*6400 / surface_vel

    print *,"T_surfacewaves:", T_surfacewaves

    ! debug output
    !if (DISPLAY_DETAILS) then
    !print*,'debug: '
    !print*,'  yr,jda,ho,mi,sec : ',yr,jda,ho,mi,sec
    !print*,'  net,sta,chan_dat : ',net,sta,chan_dat
    !print*,'  dist,az,baz,slat,slon : ',dist,az,baz,slat,slon
    !print*,'  cmp          = ',cmp
    !print*,'  dist           = ',dist
    !print*,'  T_surfacewaves = ',T_surfacewaves
    !print*
    !endif

    ! reads in window picks
    !read(21,*,iostat=ios) npicks
    !if (ios /= 0) stop 'Error reading windows npicks'
    npicks=win(ipair)%num_win

    ! loops/skips over picks (start/end times)
    do ipicks=1,npicks

      !read(21,*,iostat=ios) tstart, tend
      !if (ios /= 0) stop 'Error reading window pick: tstart and tend'
      tstart=win(ipair)%t_start(ipicks)
      tend=win(ipair)%t_end(ipicks)

      !tstart = max(tstart,t0)
      !tend = min(tend, t0+(npts-1)*dt)

      ! body wave picks
      if( tend <= T_surfacewaves ) then
        if( cmp(1:1) == "Z" ) num_P_SV_V = num_P_SV_V + 1.d0
        if( cmp(1:1) == "R" ) num_P_SV_R = num_P_SV_R + 1.d0
        if( cmp(1:1) == "T" ) num_SH_T = num_SH_T + 1.d0
      else
      ! surface wave picks
        if( cmp(1:1) == "Z" ) num_Rayleigh_V = num_Rayleigh_V + 1.d0
        if( cmp(1:1) == "R" ) num_Rayleigh_R = num_Rayleigh_R + 1.d0
        if( cmp(1:1) == "T" ) num_Love_T = num_Love_T + 1.d0
      endif

    enddo !end of npicks

    ! determines all picks on a trace component 
    ! (also cross-check comp name in filename)
    ! transverse
    !iposition = INDEX( trim(synfile), comp_T, .false. )
    !if( iposition > 3 .and. iposition < len_trim( synfile) ) then
    !  if( cmp(1:1) /= "T" ) stop 'error T component pick'
    if(cmp(1:1) == "T") then
      picks_T = picks_T + npicks
    !else
      ! radial
      !iposition = INDEX( trim(synfile), comp_R, .false. )
      !if( iposition > 3 .and. iposition < len_trim( synfile) ) then
        !if( cmp(1:1) /= "R" ) stop 'error R component pick'
    elseif(cmp(1:1) == "R") then 
      picks_R = picks_R + npicks
     ! else
        ! vertical
        !iposition = INDEX( trim(synfile), comp_Z, .false. )
        !if( iposition > 3 .and. iposition < len_trim( synfile) ) then
          !if( cmp(1:1) /= "Z" ) stop 'error Z component pick'
    elseif(cmp(1:1) == "Z") then
      picks_Z = picks_Z + npicks
    endif

  enddo ! end of npairs

  !close(21)


  ! check with total number of picks per component
  if( nint( num_P_SV_R + num_Rayleigh_R ) /= picks_R ) stop 'error R picks'
  if( nint( num_P_SV_V + num_Rayleigh_V ) /= picks_Z ) stop 'error Z picks'
  if( nint( num_SH_T + num_Love_T ) /= picks_T ) stop 'error T picks'

  !if( DISPLAY_DETAILS ) then
    print*
    print*,'weighting measurements: '
    print*,'  picks T:',picks_T
    print*,'  picks R:',picks_R
    print*,'  picks Z:',picks_Z
    print*
    print*,'  picks P_SV_R: ',nint(num_P_SV_R)
    print*,'  picks P_SV_V: ',nint(num_P_SV_V)
    print*,'  picks SH_T  : ',nint(num_SH_T)
    print*,'  picks Rayleigh_R: ',nint(num_Rayleigh_R)
    print*,'  picks Rayleigh_V: ',nint(num_Rayleigh_V)
    print*,'  picks Love_T    : ',nint(num_Love_T)
    print*
  !endif


  ! sets up weights based on picks
  weight_T = 1.0d0
  weight_R = 1.0d0
  weight_Z = 1.0d0

  ! weighting tries to balance love waves (tranverse) versus rayleigh waves (radial + vertical)
  !if( picks_T > 0 ) then
  !  if( picks_R + picks_Z > 0 ) weight_T = dble(picks_R + picks_Z)/dble(picks_T)
  !endif

  ! use normalization as weights
  if( picks_T > 0 ) weight_T = 1.d0 / picks_T
  if( picks_R > 0 ) weight_R = 1.d0 / picks_R
  if( picks_Z > 0 ) weight_Z = 1.d0 / picks_Z

  ! use normalization (no traces means zero weights)
  if( num_P_SV_R > 0. ) num_P_SV_R = 1.d0 / num_P_SV_R
  if( num_P_SV_V > 0. ) num_P_SV_V = 1.d0 / num_P_SV_V
  if( num_SH_T > 0. ) num_SH_T = 1.d0 / num_SH_T
  if( num_Rayleigh_R > 0. ) num_Rayleigh_R = 1.d0 / num_Rayleigh_R
  if( num_Rayleigh_V > 0. ) num_Rayleigh_V = 1.d0 / num_Rayleigh_V
  if( num_Love_T > 0. ) num_Love_T = 1.d0 / num_Love_T

  print*,'  weight of P_SV_R:',num_P_SV_R
  print*,'  weight of P_SV_V:',num_P_SV_V
  print*,'  weight of SH_T  :',num_SH_T
  print*,'  weight of Rayleigh_R:',num_Rayleigh_R
  print*,'  weight of Rayleigh_V:',num_Rayleigh_V
  print*,'  weight of Love_T:', num_Love_T

  !copy all the var to struct
  ma_par%weight_T=weight_T
  ma_par%weight_R=weight_R
  ma_par%weight_Z=weight_Z
  ma_par%num_P_SV_R=num_P_SV_R
  ma_par%num_P_SV_V=num_P_SV_V
  ma_par%num_SH_T=num_SH_T
  ma_par%num_Rayleigh_R=num_Rayleigh_R
  ma_par%num_Rayleigh_V=num_Rayleigh_V
  ma_par%num_Love_T=num_Love_T

end subroutine setup_measure_adj_weighting_asdf


!-------------------------------------------------.
!copy weighting_par, called by measure_adj        !
!-------------------------------------------------'
subroutine copy_weighting_par_to_local(weighting_par)

  use ma_struct
  use ma_weighting

  type(ma_weighting_par_struct) :: weighting_par

  weight_T = weighting_par%weight_T
  weight_R = weighting_par%weight_R
  weight_Z = weighting_par%weight_Z
  num_P_SV_R = weighting_par%num_P_SV_R
  num_P_SV_V = weighting_par%num_P_SV_V
  num_SH_T   = weighting_par%num_SH_T
  num_Rayleigh_R      = weighting_par%num_Rayleigh_R
  num_Rayleigh_V      = weighting_par%num_Rayleigh_V
  num_Rayleigh_Love_T = weighting_par%num_Love_T

end subroutine copy_weighting_par_to_local


!-------------------------------------------------.
!copu ma_par to local, called by measure_adj      !
!-------------------------------------------------'
subroutine copy_ma_par_to_local(ma_par, fstart0, fend0,tt,dtt,nn,chan)

  use ma_variables
  use ma_struct
  implicit none
  type(ma_par_struct) :: ma_par
  double precision :: fstart0, fend0, tt, dtt
  integer :: nn
  character(len=10) :: chan
  integer :: ios

  tt      = ma_par%tt
  dtt     = ma_par%dtt
  nn      = ma_par%nn
  imeas0  = ma_par%imeas0
  chan    = ma_par%chan
  TLONG   = ma_par%TLONG
  TSHORT  = ma_par%TSHORT
  RUN_BANDPASS    = ma_par%RUN_BANDPASS
  DISPLAY_DETAILS = ma_par%DISPLAY_DETAILS
  OUTPUT_MEASUREMENT_FILES = ma_par%OUTPUT_MEASUREMENT_FILES
  COMPUTE_ADJOINT_SOURCE   = ma_par%COMPUTE_ADJOINT_SOURCE
  TSHIFT_MIN = ma_par%TSHIFT_MIN
  TSHIFT_MAX = ma_par%TSHIFT_MAX
  DLNA_MIN   = ma_par%DLNA_MIN
  DLNA_MAX   = ma_par%DLNA_MAX
  CC_MIN     = ma_par%CC_MIN
  ERROR_TYPE = ma_par%ERROR_TYPE
  DT_SIGMA_MIN    = ma_par%DT_SIGMA_MIN
  DLNA_SIGMA_MIN  = ma_par%DLNA_SIGMA_MIN
  ITAPER  = ma_par%ITAPER
  WTR     = ma_par%WTR
  NPI     = ma_par%NPI
  DT_FAC  = ma_par%DT_FAC
  ERR_FAC = ma_par%ERR_FAC
  DT_MAX_SCALE      = ma_par%DT_MAX_SCALE
  NCYCLE_IN_WINDOW  = ma_par%NCYCLE_IN_WINDOW
  USE_PHYSICAL_DISPERSION = ma_par%USE_PHYSICAL_DISPERSION

  is_mtm0 = ma_par%is_mtm0

  imeas  = imeas0
  fstart0 = ma_par%fstart0
  fend0  = ma_par%fend0
  is_mtm = is_mtm0

end subroutine copy_ma_par_to_local

end module measure_adj_subs
